# Overview {#overview}

There is a strong relationship between the hierarchical forms of data structure used in geo-spatial analysis and in the grammars of data analysis and graphics. Currently the translation between geo-spatial forms and the modern analysis and graphics grammars is disjointed and sometimes awkward. In this overview we present a way of classifying and structuring geo-spatial forms that is consistent and complementary to those used in the grammars, and allows the technical and specialist requirements of geo-spatial to be modularized appropriately, while allowing other uses to be more flexible and available. 

GIS-based vector data provides a complex set of data structures, and the [modern R form](https://cran.r-project.org/package=sf) is compliant with the [simple features standard](https://en.wikipedia.org/wiki/Simple_Features). In R these are stored in *nested lists* where the physical structure of the data is isomorphic to an interpretation of the logical structures in the data. 

Nested lists of data can be inverted and stored in an *inside-out* way as normal data frames. Various packages provide conversions between nested and table forms,  but there is no overall approach that works in the general case and no categorization of the common conversions that are most useful. Worse, there are fragmented approaches spread across dozens of implementations without one central framework or vision.  There is room for extension and improvement to the handling of data structures with conversion tools, and ideally a central form-converter framework. Here we focus on GIS vector data to show the limitations of the nested structures, and how being able to flip between representations provides much added power and provides a clear pathway forward for many complex problems that don't fit in the traditional GIS mold.

A Spatial object is a complex nested list of coordinates stored in matrices with S4 classes, with each top-level item linked by ID to rows in a data frame. A newer form to replace Spatial that handles more kinds of data sets is simple features in sf. Here the coordinates are in nested lists of matrices, except for one case where a single POINT is an atomic vector.  The `sf` package stores each object with its data frame row rather than by a remote link ID, and the package is compliant with the simple features standard which removes some ambiguities that existed in `sp`. The simple features approach is more aligned with the tidyverse principles, but does this by way of a formal API to switch from lists to data frames in pre-specified ways. 

We can define an *always data frame* analog to these data structures in two quite different ways. 

* nested data frames stored in one single data frame
* multiple data frames without nesting

The first approach is good because there is a single lowest level data frame object and there's no need to deal with more than one object. 

The latter approach encodes the nested relations by way of database ID techniques, and because each structure is a single table this is easily transferred from and to databases. This approach also provides extra flexibility for spatial data structures, that  don't fit in the simple features framework and that are generally precluded by nested structures. 

### Terminology

The types of entities that we deal with are: 

* **Objects** (some GIS call these "features", for `ggplot2` this is  "metadata" which controls aesthetics like "fill", "color")

* **Branches** - these are the parts (pieces), connected topologies like a linear path

* **Coordinates** - all geometry in a single table, identity in multiple column with object, branch, order required by the set in the table

* **Vertices** - purely geometry, with vertex-ID

* **Primitive-table** - tables of primitives, with primitive-ID 

* **Link-table** - link tables provide many-to-one relations for branches and primitives

Use "Branch" as a general term for "part" or "piece" of an individual Object (rather than "ring", "linestring", "coordinate" in the specific cases). Branch really means an isolated connected topology, i.e. "path" as in a line-string path, or a polygon ring path - but can refer to a single point in the case of "multi points". 

Use "Primitive" for the general case, 0D-Primitive is single-vertex coordinate, 1D-Primitive is two-vertex line segment, a 2D Primitive
is a triangle. 

There might be a separate table for each kind of primitive, or in wide form they can be kept together in a single table. There are long- and wide- forms for the primitives link tables, but in wide form they must have only one type (a column per vertex ID).   Branch-link tables must always be long because they have varying numbers of coordinates per branch. 

# Nested data frames

Using nesting for data frames involves the use of list columns, and provides a "structural hierarchy" where a many-to-one relationship between tables can be stored in one object. This has long been possible to create, since data frames are themselves recursive list vectors but had no wide support until the `tidyr` package provided consistent printing and subsetting.  

A nested data frame sitting in a parent row doesn't require an explicit value for the parent, and un-nesting will automatically replicate the parent rows an appropriate number of times for each child geometry. 

## Two kinds of nesting for Spatial / sf

1. Nest once, so each row has its own Coordinates table. In this form the geometry is exactly like the output of `ggplot2::fortify`, you could row bind each of these tables together with their parent's ID and use `geom_polygon` directly. 

2. Nest twice so each row has a Branch table, which in turn has its Vertex table. In this form, the branches become proper entities, and values like "hole status", or "ring parent" can be stored here. The Vertex table must keep track of the line/poly path order however, or guarantee that it will always match the structural order. 

Nesting is a completely valid way to store structures analogous to the `Spatial` and `sf` classes, so that row-apply operations may be done on the geometry within the single table list column. A fortify-like workflow can be used with unnest(x %>% select(object, attr,geom)) but this explodes the object-level row for every branch/vertex. 

*Nesting three times* for simple features multipolygons is a possibility but doesn't neessarily add clarity to the model? Does a hole need to be stored recursively inside its parent ring? Should a second line path be stored as a child of the first?  These questions raise more issues about the limitations of simple features and don't add clarity ...


# Relational view

"Relations"" are tables, referring to the task of keeping related properties together in the same row. In this view we use a scheme that will be familiar to users of databases, where a given table stores entity data. The entities are objects, branches, vertices and one-to-many links. Nesting approaches avoid the need for links, but also preclude the ability to remove duplications. Removing duplications is a key requirement for topological operations and for providing extensibility to spatial data. 

Row-bind all entity tables together, in single-nesting this is the fortify approach used in `ggplot2` for `sp`, in double-nesting this gives us three tables. 

We name these inside-out, multiple-table approaches: 

* Fortify - two tables, Object and Branch-Coordinate. 
* Branch - three tables, Object, Branch, Coordinate

Once in Branch form, we can go further by converting into Primitives form, which provides data structures and techniques not supported by simple features or any general GIS standard. 


The steps to convert to Primitives are: 

* de-duplicate vertices in geometry-space[^1] 
* convert from  from path to line segment model (PSLG, 1D Primitives, same meaning)


There are only 0D- and 1D- primitives in simple features (caveat for exotic types that are simple-features compliant by making exceptions to the branch-based standard). 

The line-segment model, or Planar Straight Line Graph (PSLG) can be used to generate two more forms: 

* identify 3-way vertex-segment relations to generate arc-node model (TopoJSON)
* generate 2D primitives from line segments via modified-Delaunay (RTriangle), or ear-clipping (rgl)


Now we have the following main types of representation

* Bespoke hierarchical (nested lists of things)
* Nested data frames (single or double)
* Fortify
* Branch
* Primitives

Each of these forms has direct applications for a variety of tasks, either for transferring between forms or for applications that are more efficient in a given form. 


## Advantages

* parts are identifiable and track-able - i.e. size of rings, length of line strings - in simple features we need to explode an object, badge it 
## Notes

[^1]: De-duplication may be in any dimensional geometric space, but for simple features this would rarely make sense to not be X,Y. 
