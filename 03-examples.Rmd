# Examples

## spbabel - two tables - round trip for sp and ggplot2

The spbabel package provides a straightforward workflow for converting from sp Spatial objects to a single table of all coordinates (analogous to the fortify table), and back again. 

This requires working with two tables, and can be considered as simply starting with the sp object metadata table and then flattening out the geometry of each piece of each object into a single table - this table stores the x, y coordinates, a part identifier, a hole/island identifier for parts, the order of the coordinates within a part, and the object id. This could be a single table if all of the object metadata attributes were copied onto all of the coordinates for each object - but this is both wasteful and untidy in the sense that errors can be introduced when a one-to-many relationship is duplicated across the object ID and all the metadata values. Also may be inefficient (or not given factor/character tricks, rle and so on). 

Examples

sp to spbabel to ggplot2

ggplot2 to spbabel to sp


## Problems with ggplot2

Arguably, this is the same problem in sp in that it cannot give a "winding" rule answer for point in polygon. Also, sp originally did not cope with holes. 

```{r}
# https://edzer.github.io/UseR2016/

library(spbabel)
data(holey)
data(air, package = "spacetime")
library(sp)
nds = DE_NUTS1["Niedersachsen",]
library(ggmap)
bgMap = get_map(as.vector(bbox(nds)), source = "google", zoom = 7)
par(mar = rep(0,4))
merc = CRS("+init=epsg:3857")
plot(spTransform(nds, merc), bgMap = bgMap, col = grey(.5, alpha = .5))

library(ggplot2)
tab <- fortify(nds)


## how do we keep that hole
library(dplyr)
library(ggpolypath)
#filter(tab, hole) %>% group_by( "group") %>% distinct(group)

## treat it like a simple feature with this hideous hack
#tab$feat <- tab$group
#tab$feat[tab$hole] <- tab$feat[1]
ggplot(tab) + aes(x = long, y = lat, group = group, fill = id) + geom_polypath(col = "black")

## if we use geom_polypath, we can do it the old way
ggplot(tab) + aes(x = long, y = lat, group = group, fill = id) + geom_polypath(col = "black")

## use pathGrob and it's all fine
ggplot(filter(holey, object_ <= 2)) + 
  aes(x = x_, y = y_, group = branch_, fill = factor(object_)) + geom_polypath(col = "black")


```


## rgl - structural indices

All rgl functions that plot linked coordinates use primitives (line segments or triangles or quads) that are encoded as indexes into coordinate arrays. There is no requirement that the coordinates be unique, but they can be. Some rgl functions are use literally as an index into 3-coords, and others use homogeneous coordinates with a 4th coord (set this to one for the 3-coords behaviour). 

Rgl includes an ear clipping triangulation algorithm so that polygons can be converted to a surface composed of primitives. These surfaces are much more general than GIS polygons or triangulations, since they can "wrap -around". A clear example is given in tetrahedron3d() and in oh3d(). Ear clipping is fast, non-convex, and preserves input edges but is otherwise not suited for choosing well-formed triangles. 

The crux for the storage of objects in rgl is that each object is standalone and there's no native set for storage of more than one object. 

Show creation of rgl objects from Spatial

creation of gris objects from Rvcg/rgl


*This point is a general one in terms of the relational hierarchies*. 

## gris - four tables with vertex topology


# Examples of applying the "gris framework"

Sp objects

sf objects

ggplot2 objects

rgl objects
- difference when closed tetrahedron mesh or qmesh are used

